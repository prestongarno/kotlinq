input AcceptTopicSuggestionInput {
    clientMutationId: String

    repositoryId: ID!

    name: String!
}

type AcceptTopicSuggestionPayload {
    clientMutationId: String

    topic: Topic!
}

interface Actor {
    avatarUrl(
    size: Int): URI!

    login: String!

    resourcePath: URI!

    url: URI!
}

input AddCommentInput {
    clientMutationId: String

    subjectId: ID!

    body: String!
}

type AddCommentPayload {
    clientMutationId: String

    commentEdge: IssueCommentEdge!

    subject: Node!

    timelineEdge: IssueTimelineItemEdge!
}

input AddProjectCardInput {
    clientMutationId: String

    projectColumnId: ID!

    contentId: ID

    note: String
}

type AddProjectCardPayload {
    cardEdge: ProjectCardEdge!

    clientMutationId: String

    projectColumn: Project!
}

input AddProjectColumnInput {
    clientMutationId: String

    projectId: ID!

    name: String!
}

type AddProjectColumnPayload {
    clientMutationId: String

    columnEdge: ProjectColumnEdge!

    project: Project!
}

input AddPullRequestReviewCommentInput {
    clientMutationId: String

    pullRequestReviewId: ID!

    commitOID: GitObjectID

    body: String!

    path: String

    position: Int

    inReplyTo: ID
}

type AddPullRequestReviewCommentPayload {
    clientMutationId: String

    comment: PullRequestReviewComment!

    commentEdge: PullRequestReviewCommentEdge!
}

input AddPullRequestReviewInput {
    clientMutationId: String

    pullRequestId: ID!

    commitOID: GitObjectID

    body: String

    event: PullRequestReviewEvent

    comments: [DraftPullRequestReviewComment]
}

type AddPullRequestReviewPayload {
    clientMutationId: String

    pullRequestReview: PullRequestReview!

    reviewEdge: PullRequestReviewEdge!
}

input AddReactionInput {
    clientMutationId: String

    subjectId: ID!

    content: ReactionContent!
}

type AddReactionPayload {
    clientMutationId: String

    reaction: Reaction!

    subject: Reactable!
}

input AddStarInput {
    clientMutationId: String

    starrableId: ID!
}

type AddStarPayload {
    clientMutationId: String

    starrable: Starrable!
}

type AddedToProjectEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!
}

interface Assignable {
    assignees(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!
}

type AssignedEvent implements Node {
    actor: Actor

    assignable: Assignable!

    createdAt: DateTime!
    id: ID!

    user: User
}

type BaseRefChangedEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!
}

type BaseRefForcePushedEvent implements Node {
    actor: Actor

    afterCommit: Commit!

    beforeCommit: Commit!

    createdAt: DateTime!
    id: ID!

    pullRequest: PullRequest!

    ref: Ref
}

type Blame {
    ranges: [BlameRange!]!
}

type BlameRange {
    age: Int!

    commit: Commit!

    endingLine: Int!

    startingLine: Int!
}

type Blob implements Node, GitObject {
    abbreviatedOid: String!

    byteSize: Int!

    commitResourcePath: URI!

    commitUrl: URI!
    id: ID!

    isBinary: Boolean!

    isTruncated: Boolean!

    oid: GitObjectID!

    repository: Repository!

    text: String
}

type Bot implements Node, Actor, UniformResourceLocatable {
    avatarUrl(
    size: Int): URI!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    login: String!

    resourcePath: URI!

    url: URI!
}

interface Closable {
    closed: Boolean!
}

type ClosedEvent implements Node {
    actor: Actor

    closable: Closable!

    commit: Commit

    createdAt: DateTime!
    id: ID!
}

type CodeOfConduct {
    body: String

    key: String!

    name: String!

    url: URI
}

interface Comment {
    author: Actor

    authorAssociation: CommentAuthorAssociation!

    body: String!

    bodyHTML: HTML!

    createdAt: DateTime!

    createdViaEmail: Boolean!

    editor: Actor
    id: ID!

    lastEditedAt: DateTime

    publishedAt: DateTime

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    viewerDidAuthor: Boolean!
}

enum CommentAuthorAssociation {
    MEMBER

    OWNER

    COLLABORATOR

    CONTRIBUTOR

    FIRST_TIME_CONTRIBUTOR

    NONE
}

enum CommentCannotUpdateReason {
    INSUFFICIENT_ACCESS

    LOCKED

    LOGIN_REQUIRED

    MAINTENANCE

    VERIFIED_EMAIL_REQUIRED
}

type CommentDeletedEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!
}

type Commit implements Node, GitObject, Subscribable {
    abbreviatedOid: String!

    author: GitActor

    authoredByCommitter: Boolean!

    blame(
    path: String!): Blame!

    comments(
    first: Int

    after: String

    last: Int

    before: String): CommitCommentConnection!

    commitResourcePath: URI!

    commitUrl: URI!

    committedDate: DateTime!

    committedViaWeb: Boolean!

    committer: GitActor

    history(
    first: Int

    after: String

    last: Int

    before: String

    path: String

    author: CommitAuthor

    since: GitTimestamp

    until: GitTimestamp): CommitHistoryConnection!
    id: ID!

    message: String!

    messageBody: String!

    messageBodyHTML: HTML!

    messageHeadline: String!

    messageHeadlineHTML: HTML!

    oid: GitObjectID!

    repository: Repository!

    resourcePath: URI!

    signature: GitSignature

    status: Status

    tree: Tree!

    treeResourcePath: URI!

    treeUrl: URI!

    url: URI!

    viewerCanSubscribe: Boolean!

    viewerSubscription: SubscriptionState!
}

input CommitAuthor {
    id: ID

    emails: [String!]
}

type CommitComment implements Node, Comment, Deletable, Updatable, UpdatableComment, Reactable, RepositoryNode {
    author: Actor

    authorAssociation: CommentAuthorAssociation!

    body: String!

    bodyHTML: HTML!

    commit: Commit!

    createdAt: DateTime!

    createdViaEmail: Boolean!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    editor: Actor
    id: ID!

    lastEditedAt: DateTime

    path: String

    position: Int

    publishedAt: DateTime

    reactionGroups: [ReactionGroup!]

    reactions(
    first: Int

    after: String

    last: Int

    before: String

    content: ReactionContent

    orderBy: ReactionOrder): ReactionConnection!

    repository: Repository!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    viewerCanDelete: Boolean!

    viewerCanReact: Boolean!

    viewerCanUpdate: Boolean!

    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

    viewerDidAuthor: Boolean!
}

type CommitCommentConnection {
    edges: [CommitCommentEdge]

    nodes: [CommitComment]

    pageInfo: PageInfo!

    totalCount: Int!
}

type CommitCommentEdge {
    cursor: String!

    node: CommitComment
}

type CommitCommentThread implements Node, RepositoryNode {
    comments(
    first: Int

    after: String

    last: Int

    before: String): CommitCommentConnection!

    commit: Commit!
    id: ID!

    path: String

    position: Int

    repository: Repository!
}

type CommitEdge {
    cursor: String!

    node: Commit
}

type CommitHistoryConnection {
    edges: [CommitEdge]

    nodes: [Commit]

    pageInfo: PageInfo!
}

type ConvertedNoteToIssueEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!
}

input CreateProjectInput {
    clientMutationId: String

    ownerId: ID!

    name: String!

    body: String
}

type CreateProjectPayload {
    clientMutationId: String

    project: Project!
}

scalar DateTime

input DeclineTopicSuggestionInput {
    clientMutationId: String

    repositoryId: ID!

    name: String!

    reason: TopicSuggestionDeclineReason!
}

type DeclineTopicSuggestionPayload {
    clientMutationId: String

    topic: Topic!
}

enum DefaultRepositoryPermissionField {
    READ

    WRITE

    ADMIN
}

interface Deletable {
    viewerCanDelete: Boolean!
}

input DeleteProjectCardInput {
    clientMutationId: String

    cardId: ID!
}

type DeleteProjectCardPayload {
    clientMutationId: String

    column: ProjectColumn!

    deletedCardId: ID!
}

input DeleteProjectColumnInput {
    clientMutationId: String

    columnId: ID!
}

type DeleteProjectColumnPayload {
    clientMutationId: String

    deletedColumnId: ID!

    project: Project!
}

input DeleteProjectInput {
    clientMutationId: String

    projectId: ID!
}

type DeleteProjectPayload {
    clientMutationId: String

    owner: ProjectOwner!
}

input DeletePullRequestReviewInput {
    clientMutationId: String

    pullRequestReviewId: ID!
}

type DeletePullRequestReviewPayload {
    clientMutationId: String

    pullRequestReview: PullRequestReview!
}

type DemilestonedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    milestoneTitle: String!

    subject: MilestoneItem!
}

type DeployedEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    deployment: Deployment!
    id: ID!

    pullRequest: PullRequest!

    ref: Ref
}

type Deployment implements Node {
    commit: Commit

    createdAt: DateTime!

    creator: Actor

    environment: String
    id: ID!

    latestStatus: DeploymentStatus

    repository: Repository!

    state: DeploymentState

    statuses(
    first: Int

    after: String

    last: Int

    before: String): DeploymentStatusConnection
}

type DeploymentConnection {
    edges: [DeploymentEdge]

    nodes: [Deployment]

    pageInfo: PageInfo!

    totalCount: Int!
}

type DeploymentEdge {
    cursor: String!

    node: Deployment
}

enum DeploymentState {
    ABANDONED

    ACTIVE

    DESTROYED

    ERROR

    FAILURE

    INACTIVE

    PENDING
}

type DeploymentStatus implements Node {
    creator: Actor

    deployment: Deployment!

    description: String

    environmentUrl: URI
    id: ID!

    logUrl: URI

    state: DeploymentStatusState!
}

type DeploymentStatusConnection {
    edges: [DeploymentStatusEdge]

    nodes: [DeploymentStatus]

    pageInfo: PageInfo!

    totalCount: Int!
}

type DeploymentStatusEdge {
    cursor: String!

    node: DeploymentStatus
}

enum DeploymentStatusState {
    PENDING

    SUCCESS

    FAILURE

    INACTIVE

    ERROR
}

input DismissPullRequestReviewInput {
    clientMutationId: String

    pullRequestReviewId: ID!

    message: String!
}

type DismissPullRequestReviewPayload {
    clientMutationId: String

    pullRequestReview: PullRequestReview!
}

input DraftPullRequestReviewComment {
    path: String!

    position: Int!

    body: String!
}

type ExternalIdentity implements Node {
    guid: String!
    id: ID!

    organizationInvitation: OrganizationInvitation

    samlIdentity: ExternalIdentitySamlAttributes

    scimIdentity: ExternalIdentityScimAttributes

    user: User
}

type ExternalIdentityConnection {
    edges: [ExternalIdentityEdge]

    nodes: [ExternalIdentity]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ExternalIdentityEdge {
    cursor: String!

    node: ExternalIdentity
}

type ExternalIdentitySamlAttributes {
    nameId: String
}

type ExternalIdentityScimAttributes {
    username: String
}

type FollowerConnection {
    edges: [UserEdge]

    nodes: [User]

    pageInfo: PageInfo!

    totalCount: Int!
}

type FollowingConnection {
    edges: [UserEdge]

    nodes: [User]

    pageInfo: PageInfo!

    totalCount: Int!
}

type Gist implements Node, Starrable {
    comments(
    first: Int

    after: String

    last: Int

    before: String): GistCommentConnection!

    createdAt: DateTime!

    description: String
    id: ID!

    isPublic: Boolean!

    name: String!

    owner: RepositoryOwner

    stargazers(
    first: Int

    after: String

    last: Int

    before: String

    orderBy: StarOrder): StargazerConnection!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    viewerHasStarred: Boolean!
}

type GistComment implements Node, Comment, Deletable, Updatable, UpdatableComment {
    author: Actor

    authorAssociation: CommentAuthorAssociation!

    body: String!

    bodyHTML: HTML!

    createdAt: DateTime!

    createdViaEmail: Boolean!

    editor: Actor
    id: ID!

    lastEditedAt: DateTime

    publishedAt: DateTime

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    viewerCanDelete: Boolean!

    viewerCanUpdate: Boolean!

    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

    viewerDidAuthor: Boolean!
}

type GistCommentConnection {
    edges: [GistCommentEdge]

    nodes: [GistComment]

    pageInfo: PageInfo!

    totalCount: Int!
}

type GistCommentEdge {
    cursor: String!

    node: GistComment
}

type GistConnection {
    edges: [GistEdge]

    nodes: [Gist]

    pageInfo: PageInfo!

    totalCount: Int!
}

type GistEdge {
    cursor: String!

    node: Gist
}

enum GistPrivacy {
    PUBLIC

    SECRET

    ALL
}

type GitActor {
    avatarUrl(
    size: Int): URI!

    date: GitTimestamp

    email: String

    name: String

    user: User
}

interface GitObject {
    abbreviatedOid: String!

    commitResourcePath: URI!

    commitUrl: URI!
    id: ID!

    oid: GitObjectID!

    repository: Repository!
}

scalar GitObjectID

interface GitSignature {
    email: String!

    isValid: Boolean!

    payload: String!

    signature: String!

    signer: User

    state: GitSignatureState!
}

enum GitSignatureState {
    VALID

    INVALID

    MALFORMED_SIG

    UNKNOWN_KEY

    BAD_EMAIL

    UNVERIFIED_EMAIL

    NO_USER

    UNKNOWN_SIG_TYPE

    UNSIGNED

    GPGVERIFY_UNAVAILABLE

    GPGVERIFY_ERROR

    NOT_SIGNING_KEY

    EXPIRED_KEY
}

scalar GitTimestamp

type GpgSignature implements GitSignature {
    email: String!

    isValid: Boolean!

    keyId: String

    payload: String!

    signature: String!

    signer: User

    state: GitSignatureState!
}

scalar HTML

type HeadRefDeletedEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    headRef: Ref

    headRefName: String!
    id: ID!

    pullRequest: PullRequest!
}

type HeadRefForcePushedEvent implements Node {
    actor: Actor

    afterCommit: Commit!

    beforeCommit: Commit!

    createdAt: DateTime!
    id: ID!

    pullRequest: PullRequest!

    ref: Ref
}

type HeadRefRestoredEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    pullRequest: PullRequest!
}

type Issue implements Node, Assignable, Closable, Comment, Updatable, UpdatableComment, Labelable, Lockable, Reactable, RepositoryNode, Subscribable, UniformResourceLocatable {
    assignees(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!

    author: Actor

    authorAssociation: CommentAuthorAssociation!

    body: String!

    bodyHTML: HTML!

    bodyText: String!

    closed: Boolean!

    comments(
    first: Int

    after: String

    last: Int

    before: String): IssueCommentConnection!

    createdAt: DateTime!

    createdViaEmail: Boolean!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    editor: Actor
    id: ID!

    labels(
    first: Int

    after: String

    last: Int

    before: String): LabelConnection

    lastEditedAt: DateTime

    locked: Boolean!

    milestone: Milestone

    number: Int!

    participants(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!

    publishedAt: DateTime

    reactionGroups: [ReactionGroup!]

    reactions(
    first: Int

    after: String

    last: Int

    before: String

    content: ReactionContent

    orderBy: ReactionOrder): ReactionConnection!

    repository: Repository!

    resourcePath: URI!

    state: IssueState!

    timeline(
    first: Int

    after: String

    last: Int

    before: String

    since: DateTime): IssueTimelineConnection!

    title: String!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!

    viewerCanReact: Boolean!

    viewerCanSubscribe: Boolean!

    viewerCanUpdate: Boolean!

    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

    viewerDidAuthor: Boolean!

    viewerSubscription: SubscriptionState!
}

type IssueComment implements Node, Comment, Deletable, Updatable, UpdatableComment, Reactable, RepositoryNode {
    author: Actor

    authorAssociation: CommentAuthorAssociation!

    body: String!

    bodyHTML: HTML!

    bodyText: String!

    createdAt: DateTime!

    createdViaEmail: Boolean!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    editor: Actor
    id: ID!

    issue: Issue!

    lastEditedAt: DateTime

    publishedAt: DateTime

    reactionGroups: [ReactionGroup!]

    reactions(
    first: Int

    after: String

    last: Int

    before: String

    content: ReactionContent

    orderBy: ReactionOrder): ReactionConnection!

    repository: Repository!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    viewerCanDelete: Boolean!

    viewerCanReact: Boolean!

    viewerCanUpdate: Boolean!

    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

    viewerDidAuthor: Boolean!
}

type IssueCommentConnection {
    edges: [IssueCommentEdge]

    nodes: [IssueComment]

    pageInfo: PageInfo!

    totalCount: Int!
}

type IssueCommentEdge {
    cursor: String!

    node: IssueComment
}

type IssueConnection {
    edges: [IssueEdge]

    nodes: [Issue]

    pageInfo: PageInfo!

    totalCount: Int!
}

type IssueEdge {
    cursor: String!

    node: Issue
}

union IssueOrPullRequest = Issue | PullRequest

input IssueOrder {
    field: IssueOrderField!

    direction: OrderDirection!
}

enum IssueOrderField {
    CREATED_AT

    UPDATED_AT

    COMMENTS
}

enum IssuePubSubTopic {
    UPDATED

    MARKASREAD
}

enum IssueState {
    OPEN

    CLOSED
}

type IssueTimelineConnection {
    edges: [IssueTimelineItemEdge]

    nodes: [IssueTimelineItem]

    pageInfo: PageInfo!

    totalCount: Int!
}

union IssueTimelineItem = Commit | IssueComment | ClosedEvent | ReopenedEvent | SubscribedEvent | UnsubscribedEvent | ReferencedEvent | AssignedEvent | UnassignedEvent | LabeledEvent | UnlabeledEvent | MilestonedEvent | DemilestonedEvent | RenamedTitleEvent | LockedEvent | UnlockedEvent

type IssueTimelineItemEdge {
    cursor: String!

    node: IssueTimelineItem
}

type Label implements Node {
    color: String!
    id: ID!

    issues(
    first: Int

    after: String

    last: Int

    before: String

    labels: [String!]

    orderBy: IssueOrder

    states: [IssueState!]): IssueConnection!

    name: String!

    pullRequests(
    first: Int

    after: String

    last: Int

    before: String): PullRequestConnection

    repository: Repository!
}

type LabelConnection {
    edges: [LabelEdge]

    nodes: [Label]

    pageInfo: PageInfo!

    totalCount: Int!
}

type LabelEdge {
    cursor: String!

    node: Label
}

interface Labelable {
    labels(
    first: Int

    after: String

    last: Int

    before: String): LabelConnection
}

type LabeledEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    label: Label!

    labelable: Labelable!
}

type Language implements Node {
    color: String
    id: ID!

    name: String!
}

type LanguageConnection {
    edges: [LanguageEdge]

    nodes: [Language]

    pageInfo: PageInfo!

    totalCount: Int!

    totalSize: Int!
}

type LanguageEdge {
    cursor: String!
    node: Language!

    size: Int!
}

input LanguageOrder {
    field: LanguageOrderField!

    direction: OrderDirection!
}

enum LanguageOrderField {
    SIZE
}

interface Lockable {
    locked: Boolean!
}

type LockedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    lockable: Lockable!
}

type MentionedEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!
}

enum MergeableState {
    MERGEABLE

    CONFLICTING

    UNKNOWN
}

type MergedEvent implements Node, UniformResourceLocatable {
    actor: Actor

    commit: Commit

    createdAt: DateTime!
    id: ID!

    mergeRef: Ref

    mergeRefName: String!

    pullRequest: PullRequest!

    resourcePath: URI!

    url: URI!
}

type Milestone implements Node, UniformResourceLocatable {
    creator: Actor

    description: String

    dueOn: DateTime
    id: ID!

    number: Int!

    repository: Repository!

    resourcePath: URI!

    state: MilestoneState!

    title: String!

    url: URI!
}

type MilestoneConnection {
    edges: [MilestoneEdge]

    nodes: [Milestone]

    pageInfo: PageInfo!

    totalCount: Int!
}

type MilestoneEdge {
    cursor: String!

    node: Milestone
}

union MilestoneItem = Issue | PullRequest

enum MilestoneState {
    OPEN

    CLOSED
}

type MilestonedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    milestoneTitle: String!

    subject: MilestoneItem!
}

input MoveProjectCardInput {
    clientMutationId: String

    cardId: ID!

    columnId: ID!

    afterCardId: ID
}

type MoveProjectCardPayload {
    cardEdge: ProjectCardEdge!

    clientMutationId: String
}

input MoveProjectColumnInput {
    clientMutationId: String

    columnId: ID!

    afterColumnId: ID
}

type MoveProjectColumnPayload {
    clientMutationId: String

    columnEdge: ProjectColumnEdge!
}

type MovedColumnsInProjectEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!
}

type Mutation {
    acceptTopicSuggestion(input: AcceptTopicSuggestionInput!): AcceptTopicSuggestionPayload
    addComment(input: AddCommentInput!): AddCommentPayload
    addProjectCard(input: AddProjectCardInput!): AddProjectCardPayload
    addProjectColumn(input: AddProjectColumnInput!): AddProjectColumnPayload
    addPullRequestReview(input: AddPullRequestReviewInput!): AddPullRequestReviewPayload
    addPullRequestReviewComment(input: AddPullRequestReviewCommentInput!): AddPullRequestReviewCommentPayload
    addReaction(input: AddReactionInput!): AddReactionPayload
    addStar(input: AddStarInput!): AddStarPayload
    createProject(input: CreateProjectInput!): CreateProjectPayload
    declineTopicSuggestion(input: DeclineTopicSuggestionInput!): DeclineTopicSuggestionPayload
    deleteProject(input: DeleteProjectInput!): DeleteProjectPayload
    deleteProjectCard(input: DeleteProjectCardInput!): DeleteProjectCardPayload
    deleteProjectColumn(input: DeleteProjectColumnInput!): DeleteProjectColumnPayload
    deletePullRequestReview(input: DeletePullRequestReviewInput!): DeletePullRequestReviewPayload
    dismissPullRequestReview(input: DismissPullRequestReviewInput!): DismissPullRequestReviewPayload
    moveProjectCard(input: MoveProjectCardInput!): MoveProjectCardPayload
    moveProjectColumn(input: MoveProjectColumnInput!): MoveProjectColumnPayload
    removeOutsideCollaborator(input: RemoveOutsideCollaboratorInput!): RemoveOutsideCollaboratorPayload
    removeReaction(input: RemoveReactionInput!): RemoveReactionPayload
    removeStar(input: RemoveStarInput!): RemoveStarPayload
    requestReviews(input: RequestReviewsInput!): RequestReviewsPayload
    submitPullRequestReview(input: SubmitPullRequestReviewInput!): SubmitPullRequestReviewPayload
    updateProject(input: UpdateProjectInput!): UpdateProjectPayload
    updateProjectCard(input: UpdateProjectCardInput!): UpdateProjectCardPayload
    updateProjectColumn(input: UpdateProjectColumnInput!): UpdateProjectColumnPayload
    updatePullRequestReview(input: UpdatePullRequestReviewInput!): UpdatePullRequestReviewPayload
    updatePullRequestReviewComment(input: UpdatePullRequestReviewCommentInput!): UpdatePullRequestReviewCommentPayload
    updateSubscription(input: UpdateSubscriptionInput!): UpdateSubscriptionPayload
    updateTopics(input: UpdateTopicsInput!): UpdateTopicsPayload
}

interface Node {
    id: ID!
}

enum OrderDirection {
    ASC

    DESC
}

type Organization implements Node, Actor, ProjectOwner, RepositoryOwner, UniformResourceLocatable {
    avatarUrl(
    size: Int): URI!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    isInvoiced: Boolean!

    login: String!

    members(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!

    name: String!

    newTeamResourcePath: URI!

    newTeamUrl: URI!

    organizationBillingEmail: String

    pinnedRepositories(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean): RepositoryConnection!

    project(
    number: Int!): Project

    projects(
    first: Int

    after: String

    last: Int

    before: String

    orderBy: ProjectOrder

    search: String

    states: [ProjectState!]): ProjectConnection!

    projectsResourcePath: URI!

    projectsUrl: URI!

    repositories(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean

    isFork: Boolean): RepositoryConnection!

    repository(
    name: String!): Repository

    resourcePath: URI!

    samlIdentityProvider: OrganizationIdentityProvider

    team(
    slug: String!): Team

    teams(
    first: Int

    after: String

    last: Int

    before: String

    privacy: TeamPrivacy

    role: TeamRole

    query: String

    userLogins: [String!]

    orderBy: TeamOrder

    ldapMapped: Boolean): TeamConnection!

    teamsResourcePath: URI!

    teamsUrl: URI!

    url: URI!

    viewerCanAdminister: Boolean!

    viewerCanCreateProjects: Boolean!

    viewerCanCreateRepositories: Boolean!

    viewerCanCreateTeams: Boolean!

    viewerIsAMember: Boolean!
}

type OrganizationConnection {
    edges: [OrganizationEdge]

    nodes: [Organization]

    pageInfo: PageInfo!

    totalCount: Int!
}

type OrganizationEdge {
    cursor: String!

    node: Organization
}

type OrganizationIdentityProvider implements Node {
    digestMethod: URI

    externalIdentities(
    first: Int

    after: String

    last: Int

    before: String): ExternalIdentityConnection!
    id: ID!

    idpCertificate: X509Certificate

    issuer: String

    organization: Organization

    signatureMethod: URI

    ssoUrl: URI
}

type OrganizationInvitation {
    email: String
    id: ID!

    invitee: User

    inviter: User!

    role: OrganizationInvitationRole!
}

type OrganizationInvitationConnection {
    edges: [OrganizationInvitationEdge]

    nodes: [OrganizationInvitation]

    pageInfo: PageInfo!

    totalCount: Int!
}

type OrganizationInvitationEdge {
    cursor: String!

    node: OrganizationInvitation
}

enum OrganizationInvitationRole {
    DIRECT_MEMBER

    ADMIN

    BILLING_MANAGER

    REINSTATE
}

type PageInfo {
    endCursor: String

    hasNextPage: Boolean!

    hasPreviousPage: Boolean!

    startCursor: String
}

type Project implements Node, Updatable {
    body: String

    bodyHTML: HTML!

    closedAt: DateTime

    columns(
    first: Int

    after: String

    last: Int

    before: String): ProjectColumnConnection!

    createdAt: DateTime!

    creator: Actor

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    name: String!

    number: Int!

    owner: ProjectOwner!

    resourcePath: URI!

    state: ProjectState!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!

    viewerCanUpdate: Boolean!
}

type ProjectCard implements Node {
    column: ProjectColumn

    content: ProjectCardItem

    createdAt: DateTime!

    creator: Actor

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    note: String

    project: Project!

    projectColumn: ProjectColumn! @deprecated(reason: "Use ProjectCard.column instead. The associated column will be null if the card is in a pending state.")

    resourcePath: URI!

    state: ProjectCardState

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!
}

type ProjectCardConnection {
    edges: [ProjectCardEdge]

    nodes: [ProjectCard]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ProjectCardEdge {
    cursor: String!

    node: ProjectCard
}

union ProjectCardItem = Issue | PullRequest

enum ProjectCardState {
    CONTENT_ONLY

    NOTE_ONLY

    REDACTED
}

type ProjectColumn implements Node {
    cards(
    first: Int

    after: String

    last: Int

    before: String): ProjectCardConnection!

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    name: String!

    project: Project!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")
}

type ProjectColumnConnection {
    edges: [ProjectColumnEdge]

    nodes: [ProjectColumn]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ProjectColumnEdge {
    cursor: String!

    node: ProjectColumn
}

type ProjectConnection {
    edges: [ProjectEdge]

    nodes: [Project]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ProjectEdge {
    cursor: String!

    node: Project
}

input ProjectOrder {
    field: ProjectOrderField!

    direction: OrderDirection!
}

enum ProjectOrderField {
    CREATED_AT

    UPDATED_AT

    NAME
}

interface ProjectOwner {
    id: ID!

    project(
    number: Int!): Project

    projects(
    first: Int

    after: String

    last: Int

    before: String

    orderBy: ProjectOrder

    search: String

    states: [ProjectState!]): ProjectConnection!

    projectsResourcePath: URI!

    projectsUrl: URI!

    viewerCanCreateProjects: Boolean!
}

enum ProjectState {
    OPEN

    CLOSED
}

type ProtectedBranch implements Node {
    creator: Actor

    hasDismissableStaleReviews: Boolean!

    hasRequiredReviews: Boolean!

    hasRequiredStatusChecks: Boolean!

    hasRestrictedPushes: Boolean!

    hasRestrictedReviewDismissals: Boolean!

    hasStrictRequiredStatusChecks: Boolean!
    id: ID!

    isAdminEnforced: Boolean!

    name: String!

    pushAllowances(
    first: Int

    after: String

    last: Int

    before: String): PushAllowanceConnection!

    repository: Repository!

    requiredStatusCheckContexts: [String]

    reviewDismissalAllowances(
    first: Int

    after: String

    last: Int

    before: String): ReviewDismissalAllowanceConnection!
}

type ProtectedBranchConnection {
    edges: [ProtectedBranchEdge]

    nodes: [ProtectedBranch]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ProtectedBranchEdge {
    cursor: String!

    node: ProtectedBranch
}

type PullRequest implements Node, Assignable, Closable, Comment, Updatable, UpdatableComment, Labelable, Lockable, Reactable, RepositoryNode, Subscribable, UniformResourceLocatable {
    assignees(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!

    author: Actor

    authorAssociation: CommentAuthorAssociation!

    baseRef: Ref

    baseRefName: String!

    body: String!

    bodyHTML: HTML!

    bodyText: String!

    closed: Boolean!

    comments(
    first: Int

    after: String

    last: Int

    before: String): IssueCommentConnection!

    commits(
    first: Int

    after: String

    last: Int

    before: String): PullRequestCommitConnection!

    createdAt: DateTime!

    createdViaEmail: Boolean!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    editor: Actor

    headRef: Ref

    headRefName: String!

    headRepository: Repository

    headRepositoryOwner: RepositoryOwner
    id: ID!

    isCrossRepository: Boolean!

    labels(
    first: Int

    after: String

    last: Int

    before: String): LabelConnection

    lastEditedAt: DateTime

    locked: Boolean!

    mergeCommit: Commit

    mergeable: MergeableState!

    merged: Boolean!

    mergedAt: DateTime

    number: Int!

    participants(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!

    potentialMergeCommit: Commit

    publishedAt: DateTime

    reactionGroups: [ReactionGroup!]

    reactions(
    first: Int

    after: String

    last: Int

    before: String

    content: ReactionContent

    orderBy: ReactionOrder): ReactionConnection!

    repository: Repository!

    resourcePath: URI!

    revertResourcePath: URI!

    revertUrl: URI!

    reviewRequests(
    first: Int

    after: String

    last: Int

    before: String): ReviewRequestConnection

    reviews(
    first: Int

    after: String

    last: Int

    before: String

    states: [PullRequestReviewState!]): PullRequestReviewConnection

    state: PullRequestState!

    suggestedReviewers: [SuggestedReviewer]!

    timeline(
    first: Int

    after: String

    last: Int

    before: String

    since: DateTime): PullRequestTimelineConnection!

    title: String!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!

    viewerCanReact: Boolean!

    viewerCanSubscribe: Boolean!

    viewerCanUpdate: Boolean!

    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

    viewerDidAuthor: Boolean!

    viewerSubscription: SubscriptionState!
}

type PullRequestCommit implements Node, UniformResourceLocatable {
    commit: Commit!
    id: ID!

    pullRequest: PullRequest!

    resourcePath: URI!

    url: URI!
}

type PullRequestCommitConnection {
    edges: [PullRequestCommitEdge]

    nodes: [PullRequestCommit]

    pageInfo: PageInfo!

    totalCount: Int!
}

type PullRequestCommitEdge {
    cursor: String!

    node: PullRequestCommit
}

type PullRequestConnection {
    edges: [PullRequestEdge]

    nodes: [PullRequest]

    pageInfo: PageInfo!

    totalCount: Int!
}

type PullRequestEdge {
    cursor: String!

    node: PullRequest
}

enum PullRequestPubSubTopic {
    UPDATED

    MARKASREAD

    HEAD_REF
}

type PullRequestReview implements Node, Comment, Deletable, Updatable, UpdatableComment, RepositoryNode {
    author: Actor

    authorAssociation: CommentAuthorAssociation!

    body: String!

    bodyHTML: HTML!

    bodyText: String!

    comments(
    first: Int

    after: String

    last: Int

    before: String): PullRequestReviewCommentConnection!

    commit: Commit

    createdAt: DateTime!

    createdViaEmail: Boolean!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    editor: Actor
    id: ID!

    lastEditedAt: DateTime

    publishedAt: DateTime

    pullRequest: PullRequest!

    repository: Repository!

    resourcePath: URI!

    state: PullRequestReviewState!

    submittedAt: DateTime

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!

    viewerCanDelete: Boolean!

    viewerCanUpdate: Boolean!

    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

    viewerDidAuthor: Boolean!
}

type PullRequestReviewComment implements Node, Comment, Deletable, Updatable, UpdatableComment, Reactable, RepositoryNode {
    author: Actor

    authorAssociation: CommentAuthorAssociation!

    body: String!

    bodyHTML: HTML!

    bodyText: String!

    commit: Commit!

    createdAt: DateTime!

    createdViaEmail: Boolean!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    diffHunk: String!

    draftedAt: DateTime!

    editor: Actor
    id: ID!

    lastEditedAt: DateTime

    originalCommit: Commit!

    originalPosition: Int!

    path: String!

    position: Int

    publishedAt: DateTime

    pullRequest: PullRequest!

    pullRequestReview: PullRequestReview

    reactionGroups: [ReactionGroup!]

    reactions(
    first: Int

    after: String

    last: Int

    before: String

    content: ReactionContent

    orderBy: ReactionOrder): ReactionConnection!

    repository: Repository!

    resourcePath: URI!

    updatedAt: DateTime!

    url: URI!

    viewerCanDelete: Boolean!

    viewerCanReact: Boolean!

    viewerCanUpdate: Boolean!

    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

    viewerDidAuthor: Boolean!
}

type PullRequestReviewCommentConnection {
    edges: [PullRequestReviewCommentEdge]

    nodes: [PullRequestReviewComment]

    pageInfo: PageInfo!

    totalCount: Int!
}

type PullRequestReviewCommentEdge {
    cursor: String!

    node: PullRequestReviewComment
}

type PullRequestReviewConnection {
    edges: [PullRequestReviewEdge]

    nodes: [PullRequestReview]

    pageInfo: PageInfo!

    totalCount: Int!
}

type PullRequestReviewEdge {
    cursor: String!

    node: PullRequestReview
}

enum PullRequestReviewEvent {
    COMMENT

    APPROVE

    REQUEST_CHANGES

    DISMISS
}

enum PullRequestReviewState {
    PENDING

    COMMENTED

    APPROVED

    CHANGES_REQUESTED

    DISMISSED
}

type PullRequestReviewThread implements Node {
    comments(
    first: Int

    after: String

    last: Int

    before: String): PullRequestReviewCommentConnection!
    id: ID!

    pullRequest: PullRequest!
}

enum PullRequestState {
    OPEN

    CLOSED

    MERGED
}

type PullRequestTimelineConnection {
    edges: [PullRequestTimelineItemEdge]

    nodes: [PullRequestTimelineItem]

    pageInfo: PageInfo!

    totalCount: Int!
}
union PullRequestTimelineItem = Commit | CommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestReviewComment | IssueComment | ClosedEvent | ReopenedEvent | SubscribedEvent | UnsubscribedEvent | MergedEvent | ReferencedEvent | AssignedEvent | UnassignedEvent | LabeledEvent | UnlabeledEvent | MilestonedEvent | DemilestonedEvent | RenamedTitleEvent | LockedEvent | UnlockedEvent | DeployedEvent | HeadRefDeletedEvent | HeadRefRestoredEvent | HeadRefForcePushedEvent | BaseRefForcePushedEvent | ReviewRequestedEvent | ReviewRequestRemovedEvent | ReviewDismissedEvent

type PullRequestTimelineItemEdge {
    cursor: String!

    node: PullRequestTimelineItem
}

type PushAllowance implements Node {
    actor: PushAllowanceActor
    id: ID!

    protectedBranch: ProtectedBranch!
}

union PushAllowanceActor = User | Team

type PushAllowanceConnection {
    edges: [PushAllowanceEdge]

    nodes: [PushAllowance]

    pageInfo: PageInfo!

    totalCount: Int!
}

type PushAllowanceEdge {
    cursor: String!

    node: PushAllowance
}

type Query {
    codeOfConduct(key: String!): CodeOfConduct

    codesOfConduct: [CodeOfConduct]

    node(id: ID!): Node

    nodes(ids: [ID!]!): [Node]!

    organization(login: String!): Organization

    rateLimit: RateLimit

    relay: Query!

    repository(owner: String!, name: String!): Repository

    repositoryOwner(login: String!): RepositoryOwner

    resource(url: URI!): UniformResourceLocatable

    search(first: Int, after: String, last: Int, before: String, query: String!, type: SearchType!): SearchResultItemConnection!

    topic(name: String!): Topic

    user(login: String!): User

    viewer: User!
}

type RateLimit {
    cost: Int!

    limit: Int!

    remaining: Int!

    resetAt: DateTime!
}

interface Reactable {
    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    reactionGroups: [ReactionGroup!]

    reactions(
    first: Int

    after: String

    last: Int

    before: String

    content: ReactionContent

    orderBy: ReactionOrder): ReactionConnection!

    viewerCanReact: Boolean!
}

type ReactingUserConnection {
    edges: [ReactingUserEdge]

    nodes: [User]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ReactingUserEdge {
    cursor: String!
    node: User!

    reactedAt: DateTime!
}

type Reaction implements Node {
    content: ReactionContent!

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    user: User
}

type ReactionConnection {
    edges: [ReactionEdge]

    nodes: [Reaction]

    pageInfo: PageInfo!

    totalCount: Int!

    viewerHasReacted: Boolean!
}

enum ReactionContent {
    THUMBS_UP

    THUMBS_DOWN

    LAUGH

    HOORAY

    CONFUSED

    HEART
}

type ReactionEdge {
    cursor: String!

    node: Reaction
}

type ReactionGroup {
    content: ReactionContent!

    createdAt: DateTime

    subject: Reactable!

    users(
    first: Int

    after: String

    last: Int

    before: String): ReactingUserConnection!

    viewerHasReacted: Boolean!
}

input ReactionOrder {
    field: ReactionOrderField!

    direction: OrderDirection!
}

enum ReactionOrderField {
    CREATED_AT
}

type Ref implements Node {
    associatedPullRequests(
    first: Int

    after: String

    last: Int

    before: String

    states: [PullRequestState!]): PullRequestConnection!
    id: ID!

    name: String!

    prefix: String!

    repository: Repository!

    target: GitObject!
}

type RefConnection {
    edges: [RefEdge]

    nodes: [Ref]

    pageInfo: PageInfo!

    totalCount: Int!
}

type RefEdge {
    cursor: String!

    node: Ref
}

type ReferencedEvent implements Node {
    actor: Actor

    commit: Commit

    commitRepository: Repository!

    createdAt: DateTime!
    id: ID!

    isCrossReference: Boolean! @deprecated(reason: "Use ReferencedEvent.isCrossRepository instead.")

    isCrossRepository: Boolean!

    isDirectReference: Boolean!

    subject: ReferencedSubject!
}

union ReferencedSubject = Issue | PullRequest

type Release implements Node, UniformResourceLocatable {
    description: String
    id: ID!

    name: String

    publishedAt: DateTime

    releaseAsset(
    first: Int

    after: String

    last: Int

    before: String

    name: String!): ReleaseAssetConnection!

    releaseAssets(
    first: Int

    after: String

    last: Int

    before: String): ReleaseAssetConnection!

    resourcePath: URI!

    tag: Ref

    url: URI!
}

type ReleaseAsset implements Node {
    id: ID!

    name: String!

    release: Release

    url: URI!
}

type ReleaseAssetConnection {
    edges: [ReleaseAssetEdge]

    nodes: [ReleaseAsset]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ReleaseAssetEdge {
    cursor: String!

    node: ReleaseAsset
}

type ReleaseConnection {
    edges: [ReleaseEdge]

    nodes: [Release]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ReleaseEdge {
    cursor: String!

    node: Release
}

input RemoveOutsideCollaboratorInput {
    clientMutationId: String

    userId: ID!

    organizationId: ID!
}

type RemoveOutsideCollaboratorPayload {
    clientMutationId: String

    removedUser: User!
}

input RemoveReactionInput {
    clientMutationId: String

    subjectId: ID!

    content: ReactionContent!
}

type RemoveReactionPayload {
    clientMutationId: String

    reaction: Reaction!

    subject: Reactable!
}

input RemoveStarInput {
    clientMutationId: String

    starrableId: ID!
}

type RemoveStarPayload {
    clientMutationId: String

    starrable: Starrable!
}

type RemovedFromProjectEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!
}

type RenamedTitleEvent implements Node {
    actor: Actor

    createdAt: DateTime!

    currentTitle: String!
    id: ID!

    previousTitle: String!

    subject: RenamedTitleSubject!
}

union RenamedTitleSubject = Issue | PullRequest

type ReopenedEvent implements Node {
    actor: Actor

    closable: Closable!

    createdAt: DateTime!
    id: ID!
}

type Repository implements Node, ProjectOwner, Subscribable, Starrable, UniformResourceLocatable, RepositoryInfo {
    codeOfConduct: CodeOfConduct

    commitComments(
    first: Int

    after: String

    last: Int

    before: String): CommitCommentConnection!

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    defaultBranchRef: Ref

    deployments(
    first: Int

    after: String

    last: Int

    before: String): DeploymentConnection!

    description: String

    descriptionHTML: HTML!

    diskUsage: Int

    forks(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean): RepositoryConnection!

    hasIssuesEnabled: Boolean!

    hasWikiEnabled: Boolean!

    homepageUrl: URI
    id: ID!

    isFork: Boolean!

    isLocked: Boolean!

    isMirror: Boolean!

    isPrivate: Boolean!

    issue(
    number: Int!): Issue

    issueOrPullRequest(
    number: Int!): IssueOrPullRequest

    issues(
    first: Int

    after: String

    last: Int

    before: String

    labels: [String!]

    orderBy: IssueOrder

    states: [IssueState!]): IssueConnection!

    label(
    name: String!): Label

    labels(
    first: Int

    after: String

    last: Int

    before: String): LabelConnection

    languages(
    first: Int

    after: String

    last: Int

    before: String

    orderBy: LanguageOrder): LanguageConnection

    license: String

    lockReason: RepositoryLockReason

    mentionableUsers(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!

    milestone(
    number: Int!): Milestone

    milestones(
    first: Int

    after: String

    last: Int

    before: String): MilestoneConnection

    mirrorUrl: URI

    name: String!

    nameWithOwner: String!

    object(
    oid: GitObjectID

    expression: String): GitObject

    owner: RepositoryOwner!

    parent: Repository

    primaryLanguage: Language

    project(
    number: Int!): Project

    projects(
    first: Int

    after: String

    last: Int

    before: String

    orderBy: ProjectOrder

    search: String

    states: [ProjectState!]): ProjectConnection!

    projectsResourcePath: URI!

    projectsUrl: URI!

    protectedBranches(
    first: Int

    after: String

    last: Int

    before: String): ProtectedBranchConnection!

    pullRequest(
    number: Int!): PullRequest

    pullRequests(
    first: Int

    after: String

    last: Int

    before: String

    states: [PullRequestState!]

    labels: [String!]

    headRefName: String

    baseRefName: String

    orderBy: IssueOrder): PullRequestConnection!

    pushedAt: DateTime

    ref(
    qualifiedName: String!): Ref

    refs(
    first: Int

    after: String

    last: Int

    before: String

    refPrefix: String!

    direction: OrderDirection): RefConnection

    releases(
    first: Int

    after: String

    last: Int

    before: String): ReleaseConnection!

    repositoryTopics(
    first: Int

    after: String

    last: Int

    before: String): RepositoryTopicConnection!

    resourcePath: URI!

    stargazers(
    first: Int

    after: String

    last: Int

    before: String

    orderBy: StarOrder): StargazerConnection!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!

    viewerCanAdminister: Boolean!

    viewerCanCreateProjects: Boolean!

    viewerCanSubscribe: Boolean!

    viewerCanUpdateTopics: Boolean!

    viewerHasStarred: Boolean!

    viewerSubscription: SubscriptionState!

    watchers(
    first: Int

    after: String

    last: Int

    before: String): UserConnection!
}

enum RepositoryAffiliation {
    OWNER

    COLLABORATOR

    ORGANIZATION_MEMBER
}

enum RepositoryCollaboratorAffiliation {
    ALL

    OUTSIDE
}

type RepositoryConnection {
    edges: [RepositoryEdge]

    nodes: [Repository]

    pageInfo: PageInfo!

    totalCount: Int!

    totalDiskUsage: Int!
}

type RepositoryEdge {
    cursor: String!

    node: Repository
}

interface RepositoryInfo {
    createdAt: DateTime!

    description: String

    descriptionHTML: HTML!

    hasIssuesEnabled: Boolean!

    hasWikiEnabled: Boolean!

    homepageUrl: URI

    isFork: Boolean!

    isLocked: Boolean!

    isMirror: Boolean!

    isPrivate: Boolean!

    license: String

    lockReason: RepositoryLockReason

    mirrorUrl: URI

    name: String!

    nameWithOwner: String!

    owner: RepositoryOwner!

    pushedAt: DateTime

    resourcePath: URI!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!
}

type RepositoryInvitation implements Node {
    id: ID!

    invitee: User!

    inviter: User!

    repository: RepositoryInvitationRepository
}

type RepositoryInvitationRepository implements RepositoryInfo {
    createdAt: DateTime!

    description: String

    descriptionHTML: HTML!

    hasIssuesEnabled: Boolean!

    hasWikiEnabled: Boolean!

    homepageUrl: URI

    isFork: Boolean!

    isLocked: Boolean!

    isMirror: Boolean!

    isPrivate: Boolean!

    license: String

    lockReason: RepositoryLockReason

    mirrorUrl: URI

    name: String!

    nameWithOwner: String!

    owner: RepositoryOwner!

    pushedAt: DateTime

    resourcePath: URI!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!
}

enum RepositoryLockReason {
    MOVING

    BILLING

    RENAME

    MIGRATING
}

interface RepositoryNode {
    repository: Repository!
}

input RepositoryOrder {
    field: RepositoryOrderField!

    direction: OrderDirection!
}

enum RepositoryOrderField {
    CREATED_AT

    UPDATED_AT

    PUSHED_AT

    NAME

    STARGAZERS
}

interface RepositoryOwner {
    avatarUrl(
    size: Int): URI!
    id: ID!

    login: String!

    pinnedRepositories(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean): RepositoryConnection!

    repositories(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean

    isFork: Boolean): RepositoryConnection!

    repository(
    name: String!): Repository

    resourcePath: URI!

    url: URI!
}

enum RepositoryPrivacy {
    PUBLIC

    PRIVATE
}

type RepositoryTopic implements Node, UniformResourceLocatable {
    id: ID!

    resourcePath: URI!

    topic: Topic!

    url: URI!
}

type RepositoryTopicConnection {
    edges: [RepositoryTopicEdge]

    nodes: [RepositoryTopic]

    pageInfo: PageInfo!

    totalCount: Int!
}

type RepositoryTopicEdge {
    cursor: String!

    node: RepositoryTopic
}

input RequestReviewsInput {
    clientMutationId: String

    pullRequestId: ID!

    userIds: [ID!]

    teamIds: [ID!]

    union: Boolean
}

type RequestReviewsPayload {
    clientMutationId: String

    pullRequest: PullRequest!

    requestedReviewersEdge: UserEdge!
}

type ReviewDismissalAllowance implements Node {
    actor: ReviewDismissalAllowanceActor
    id: ID!

    protectedBranch: ProtectedBranch!
}

union ReviewDismissalAllowanceActor = User | Team

type ReviewDismissalAllowanceConnection {
    edges: [ReviewDismissalAllowanceEdge]

    nodes: [ReviewDismissalAllowance]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ReviewDismissalAllowanceEdge {
    cursor: String!

    node: ReviewDismissalAllowance
}

type ReviewDismissedEvent implements Node, UniformResourceLocatable {
    actor: Actor

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    message: String!

    messageHtml: HTML!

    previousReviewState: PullRequestReviewState!

    pullRequest: PullRequest!

    pullRequestCommit: PullRequestCommit

    resourcePath: URI!

    review: PullRequestReview

    url: URI!
}

type ReviewRequest implements Node {
    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")
    id: ID!

    pullRequest: PullRequest!

    reviewer: User
}

type ReviewRequestConnection {
    edges: [ReviewRequestEdge]

    nodes: [ReviewRequest]

    pageInfo: PageInfo!

    totalCount: Int!
}

type ReviewRequestEdge {
    cursor: String!

    node: ReviewRequest
}

type ReviewRequestRemovedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    pullRequest: PullRequest!

    subject: User!
}

type ReviewRequestedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    pullRequest: PullRequest!

    subject: User!
}

union SearchResultItem = Issue | PullRequest | Repository | User | Organization

type SearchResultItemConnection {
    codeCount: Int!

    edges: [SearchResultItemEdge]

    issueCount: Int!

    nodes: [SearchResultItem]

    pageInfo: PageInfo!

    repositoryCount: Int!

    userCount: Int!

    wikiCount: Int!
}

type SearchResultItemEdge {
    cursor: String!

    node: SearchResultItem
}

enum SearchType {
    ISSUE

    REPOSITORY

    USER
}

type SmimeSignature implements GitSignature {
    email: String!

    isValid: Boolean!

    payload: String!

    signature: String!

    signer: User

    state: GitSignatureState!
}

input StarOrder {
    field: StarOrderField!

    direction: OrderDirection!
}

enum StarOrderField {
    STARRED_AT
}

type StargazerConnection {
    edges: [StargazerEdge]

    nodes: [User]

    pageInfo: PageInfo!

    totalCount: Int!
}

type StargazerEdge {
    cursor: String!
    node: User!

    starredAt: DateTime!
}

interface Starrable {
    id: ID!

    stargazers(
    first: Int

    after: String

    last: Int

    before: String

    orderBy: StarOrder): StargazerConnection!

    viewerHasStarred: Boolean!
}

type StarredRepositoryConnection {
    edges: [StarredRepositoryEdge]

    nodes: [Repository]

    pageInfo: PageInfo!

    totalCount: Int!
}

type StarredRepositoryEdge {
    cursor: String!
    node: Repository!

    starredAt: DateTime!
}

type Status implements Node {
    commit: Commit

    context(
    name: String!): StatusContext

    contexts: [StatusContext!]!
    id: ID!

    state: StatusState!
}

type StatusContext implements Node {
    commit: Commit

    context: String!

    createdAt: DateTime!

    creator: Actor

    description: String
    id: ID!

    state: StatusState!

    targetUrl: URI
}

enum StatusState {
    EXPECTED

    ERROR

    FAILURE

    PENDING

    SUCCESS
}

input SubmitPullRequestReviewInput {
    clientMutationId: String

    pullRequestReviewId: ID!

    event: PullRequestReviewEvent!

    body: String
}

type SubmitPullRequestReviewPayload {
    clientMutationId: String

    pullRequestReview: PullRequestReview!
}

interface Subscribable {
    viewerCanSubscribe: Boolean!

    viewerSubscription: SubscriptionState!
}

type SubscribedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    subscribable: Subscribable!
}

enum SubscriptionState {
    UNSUBSCRIBED

    SUBSCRIBED

    IGNORED
}

type SuggestedReviewer {
    isAuthor: Boolean!

    isCommenter: Boolean!

    reviewer: User!
}

type Tag implements Node, GitObject {
    abbreviatedOid: String!

    commitResourcePath: URI!

    commitUrl: URI!
    id: ID!

    message: String

    name: String!

    oid: GitObjectID!

    repository: Repository!

    tagger: GitActor

    target: GitObject!
}

type Team implements Node {
    description: String

    editTeamResourcePath: URI!

    editTeamUrl: URI!
    id: ID!

    invitations(
    first: Int

    after: String

    last: Int

    before: String): OrganizationInvitationConnection

    name: String!

    organization: Organization!

    privacy: TeamPrivacy!

    resourcePath: URI!

    slug: String!

    url: URI!
}

type TeamConnection {
    edges: [TeamEdge]

    nodes: [Team]

    pageInfo: PageInfo!

    totalCount: Int!
}

type TeamEdge {
    cursor: String!

    node: Team
}

input TeamOrder {
    field: TeamOrderField!

    direction: OrderDirection!
}

enum TeamOrderField {
    NAME
}

enum TeamPrivacy {
    SECRET

    VISIBLE
}

enum TeamRole {
    ADMIN

    MEMBER
}

type Topic implements Node {
    id: ID!

    name: String!

    relatedTopics: [Topic!]!
}

enum TopicSuggestionDeclineReason {
    NOT_RELEVANT

    TOO_SPECIFIC

    PERSONAL_PREFERENCE

    TOO_GENERAL
}

type Tree implements Node, GitObject {
    abbreviatedOid: String!

    commitResourcePath: URI!

    commitUrl: URI!

    entries: [TreeEntry!]
    id: ID!

    oid: GitObjectID!

    repository: Repository!
}

type TreeEntry {
    mode: Int!

    name: String!

    object: GitObject

    oid: GitObjectID!

    repository: Repository!

    type: String!
}

scalar URI

type UnassignedEvent implements Node {
    actor: Actor

    assignable: Assignable!

    createdAt: DateTime!
    id: ID!

    user: User
}

interface UniformResourceLocatable {
    resourcePath: URI!

    url: URI!
}

type UnknownSignature implements GitSignature {
    email: String!

    isValid: Boolean!

    payload: String!

    signature: String!

    signer: User

    state: GitSignatureState!
}

type UnlabeledEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    label: Label!

    labelable: Labelable!
}

type UnlockedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    lockable: Lockable!
}

type UnsubscribedEvent implements Node {
    actor: Actor

    createdAt: DateTime!
    id: ID!

    subscribable: Subscribable!
}

interface Updatable {
    viewerCanUpdate: Boolean!
}

interface UpdatableComment {
    viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
}

input UpdateProjectCardInput {
    clientMutationId: String

    projectCardId: ID!

    note: String!
}

type UpdateProjectCardPayload {
    clientMutationId: String

    projectCard: ProjectCard!
}

input UpdateProjectColumnInput {
    clientMutationId: String

    projectColumnId: ID!

    name: String!
}

type UpdateProjectColumnPayload {
    clientMutationId: String

    projectColumn: ProjectColumn!
}

input UpdateProjectInput {
    clientMutationId: String

    projectId: ID!

    name: String!

    body: String

    state: ProjectState
}

type UpdateProjectPayload {
    clientMutationId: String

    project: Project!
}

input UpdatePullRequestReviewCommentInput {
    clientMutationId: String

    pullRequestReviewCommentId: ID!

    body: String!
}

type UpdatePullRequestReviewCommentPayload {
    clientMutationId: String

    pullRequestReviewComment: PullRequestReviewComment!
}

input UpdatePullRequestReviewInput {
    clientMutationId: String

    pullRequestReviewId: ID!

    body: String!
}

type UpdatePullRequestReviewPayload {
    clientMutationId: String

    pullRequestReview: PullRequestReview!
}

input UpdateSubscriptionInput {
    clientMutationId: String

    subscribableId: ID!

    state: SubscriptionState!
}

type UpdateSubscriptionPayload {
    clientMutationId: String

    subscribable: Subscribable!
}

input UpdateTopicsInput {
    clientMutationId: String

    repositoryId: ID!

    topicNames: [String!]!
}

type UpdateTopicsPayload {
    clientMutationId: String

    invalidTopicNames: [String!]

    repository: Repository!
}

type User implements Node, Actor, RepositoryOwner, UniformResourceLocatable {
    avatarUrl(
    size: Int): URI!

    bio: String

    bioHTML: HTML!

    company: String

    companyHTML: HTML!

    contributedRepositories(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean): RepositoryConnection!

    createdAt: DateTime!

    databaseId: Int @deprecated(reason: "Exposed database IDs will eventually be removed in favor of global Relay IDs.")

    email: String!

    followers(
    first: Int

    after: String

    last: Int

    before: String): FollowerConnection!

    following(
    first: Int

    after: String

    last: Int

    before: String): FollowingConnection!

    gist(
    name: String!): Gist

    gists(
    first: Int

    after: String

    last: Int

    before: String

    privacy: GistPrivacy): GistConnection!
    id: ID!

    isBountyHunter: Boolean!

    isCampusExpert: Boolean!

    isDeveloperProgramMember: Boolean!

    isEmployee: Boolean!

    isHireable: Boolean!

    isInvoiced: Boolean!

    isSiteAdmin: Boolean!

    isViewer: Boolean!

    issues(
    first: Int

    after: String

    last: Int

    before: String

    labels: [String!]

    orderBy: IssueOrder

    states: [IssueState!]): IssueConnection!

    location: String

    login: String!

    name: String

    organization(
    login: String!): Organization

    organizations(
    first: Int

    after: String

    last: Int

    before: String): OrganizationConnection!

    pinnedRepositories(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean): RepositoryConnection!

    pullRequests(
    first: Int

    after: String

    last: Int

    before: String

    states: [PullRequestState!]

    labels: [String!]

    headRefName: String

    baseRefName: String

    orderBy: IssueOrder): PullRequestConnection!

    repositories(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean

    isFork: Boolean): RepositoryConnection!

    repository(
    name: String!): Repository

    resourcePath: URI!

    starredRepositories(
    first: Int

    after: String

    last: Int

    before: String

    ownedByViewer: Boolean

    orderBy: StarOrder): StarredRepositoryConnection!

    updatedAt: DateTime! @deprecated(reason: "General type updated timestamps will eventually be replaced by other field specific timestamps.")

    url: URI!

    viewerCanFollow: Boolean!

    viewerIsFollowing: Boolean!

    watching(
    first: Int

    after: String

    last: Int

    before: String

    privacy: RepositoryPrivacy

    orderBy: RepositoryOrder

    affiliations: [RepositoryAffiliation]

    isLocked: Boolean): RepositoryConnection!

    websiteUrl: URI
}

type UserConnection {
    edges: [UserEdge]

    nodes: [User]

    pageInfo: PageInfo!

    totalCount: Int!
}

type UserEdge {
    cursor: String!

    node: User
}

scalar X509Certificate
scalar ID
