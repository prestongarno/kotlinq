{
    "docs": [
        {
            "location": "/",
            "text": "Kotlinq :  \na kotlin library for easy, type-safe GraphQL DSLs\n\u00b6\n\n\nAbout\n\u00b6\n\n\nThis project is a type-safe Kotlin DSL for GraphQL.\n\n\nProject goals\n\u00b6\n\n\nKotlinq has the goal of making GraphQL easy to integrate in an existing project in a scalable manner \nwhile taking advantage of the both pragmatic and null/type-safe nature of Kotlin. \n\n\nCheck out obligatory \nHello, world!\n page to see how kotlinq accomplishes this!\n\n\nWhat is GraphQL?\n\u00b6\n\n\nGraphQL is a thoroughly defined \nspecification\n which defines\nits architecture as structured data conforming to a simple, declarative type system.\n\n\nGraphQL is a natural way to describe \ndata types\n and their \nrelationships to other types\n\n(also known as a graph, where nodes and edges describe a confined set of data). You can learn more\nabout it \nhere\n\n\nThe GraphQL type system provides null-safety which is quite convenient.\n\n\nWhat does the name \nkotlinq\n even mean?\n\u00b6\n\n\n[Kot]lin [L]anguage [I]ntegrated [Q]ueries\n\n\nDevelopment & issue tracker\n\u00b6\n\n\nGetting started\n\u00b6\n\n\nCheck out the next section for a simple 'Hello, world!' query",
            "title": "Intro"
        },
        {
            "location": "/#kotlinq-a-kotlin-library-for-easy-type-safe-graphql-dsls",
            "text": "",
            "title": "Kotlinq :  a kotlin library for easy, type-safe GraphQL DSLs"
        },
        {
            "location": "/#about",
            "text": "This project is a type-safe Kotlin DSL for GraphQL.",
            "title": "About"
        },
        {
            "location": "/#project-goals",
            "text": "Kotlinq has the goal of making GraphQL easy to integrate in an existing project in a scalable manner \nwhile taking advantage of the both pragmatic and null/type-safe nature of Kotlin.   Check out obligatory  Hello, world!  page to see how kotlinq accomplishes this!",
            "title": "Project goals"
        },
        {
            "location": "/#what-is-graphql",
            "text": "GraphQL is a thoroughly defined  specification  which defines\nits architecture as structured data conforming to a simple, declarative type system.  GraphQL is a natural way to describe  data types  and their  relationships to other types \n(also known as a graph, where nodes and edges describe a confined set of data). You can learn more\nabout it  here  The GraphQL type system provides null-safety which is quite convenient.",
            "title": "What is GraphQL?"
        },
        {
            "location": "/#what-does-the-name-kotlinq-even-mean",
            "text": "[Kot]lin [L]anguage [I]ntegrated [Q]ueries",
            "title": "What does the name kotlinq even mean?"
        },
        {
            "location": "/#getting-started",
            "text": "Check out the next section for a simple 'Hello, world!' query",
            "title": "Getting started"
        },
        {
            "location": "/core/",
            "text": "Core (kotlinq-core)\n\u00b6\n\n\nAbout\n\u00b6\n\n\nThis is the core module which provides a set of classes to compose & extend in functionality (i.e. for creating a DSL). Below is a quick overview so that you can connect the concepts when working with any of the DSL modules. Main concepts:\n\n\n\n\nFragment\n: Main interface for composing a GraphQL request\n\n\nPrinter\n: Highly configurable class for controlling the actual GraphQL request format. Don't like curly braces? Want to decorate GraphQL types in your request with custom properties? The Printer provides an easy-to-use interface via Builders for easily and safely doing things like this.\n\n\nGraph Visitor\n: An interface for traversing a GraphQL request structure\n\n\n\n\nFragment\n\u00b6\n\n\nA Fragment, just like in the GraphQL spec, is essentially a \n\n\n\n\nType name\n\n\nSelection Set\n\n\n\n\nThe \nSelection Set\n is a declaration specifying fields from that type. They can be either:\n\n\n\n\nScalars (i.e. primitives, or your own custom ones)\n\n\nOther fragments\n\n\n\n\nA Fragment is a recursively defined data structure. In kotlinq-core, fragments and their properties do not rely on JVM reflection, but rather uses its own, simplified reflection system to enforce type safety.\n\n\nPrinter\n\u00b6\n\n\nA GraphQL request printer is composed of a\n\n\n\n\nPrintingConfiguration: Specification for the format of the request. Provided configurations are \npretty print\n and \nnon-pretty\n (single line, optimized for space)\n\n\nMetaStrategy: Specification for intercepting & transforming the printing of the actual structure of a request\n\n\n\n\nExample usage:\n\n\n val printer = Printer.fromConfiguration(PrintingConfiguration.PRETTY)\n      .toBuilder()\n      .metaStrategy(MetaStrategy.builder()\n          .includeId()\n          .includeTypename()\n          .include(\"TODO\") { fragment ->\n             fragment.typeName == \"User\"\n          }\n          .build())\n      .indent(\"\\t\")\n      .build()\n\n\n\n\nThe above \nprinter\n shows how to format your requests as pretty-printed with tab indents, and also adds a property called \"TODO\" to a fragment selection set when the fragment is of type \nUser\n.\n\n\nNote that fragments themselves can be easily formatted for standard day-to-day usage:\n\n\n  val fragment = ...\n  val stringQuery = fragment.toGraphQl(\n      pretty = true,\n      idAndTypeName = true)\n\n\n\n\nGraph Visitor\n\u00b6\n\n\nThis is an interface for analyzing fragment structure. Internally, the Printer and many other features use this interface under the hood. For example, here is the implementation of the Fragment's overload of the \nin\n operator (for checking if a fragment is defined within another one, e.g. \nif (fragment in otherFragment) doSmth();\n):\n\n\n  operator fun Fragment.contains(other: Fragment): Boolean {\n    var result = false\n\n    GraphVisitor.builder()\n        .onNotifyEnter {\n          other != it || let {\n            result = true\n            false // stop traversing, found match\n          }\n        }\n        .build()\n        .let(::traverse)\n\n    return result\n  }",
            "title": "Overview"
        },
        {
            "location": "/core/#core-kotlinq-core",
            "text": "",
            "title": "Core (kotlinq-core)"
        },
        {
            "location": "/core/#about",
            "text": "This is the core module which provides a set of classes to compose & extend in functionality (i.e. for creating a DSL). Below is a quick overview so that you can connect the concepts when working with any of the DSL modules. Main concepts:   Fragment : Main interface for composing a GraphQL request  Printer : Highly configurable class for controlling the actual GraphQL request format. Don't like curly braces? Want to decorate GraphQL types in your request with custom properties? The Printer provides an easy-to-use interface via Builders for easily and safely doing things like this.  Graph Visitor : An interface for traversing a GraphQL request structure",
            "title": "About"
        },
        {
            "location": "/core/#fragment",
            "text": "A Fragment, just like in the GraphQL spec, is essentially a    Type name  Selection Set   The  Selection Set  is a declaration specifying fields from that type. They can be either:   Scalars (i.e. primitives, or your own custom ones)  Other fragments   A Fragment is a recursively defined data structure. In kotlinq-core, fragments and their properties do not rely on JVM reflection, but rather uses its own, simplified reflection system to enforce type safety.",
            "title": "Fragment"
        },
        {
            "location": "/core/#printer",
            "text": "A GraphQL request printer is composed of a   PrintingConfiguration: Specification for the format of the request. Provided configurations are  pretty print  and  non-pretty  (single line, optimized for space)  MetaStrategy: Specification for intercepting & transforming the printing of the actual structure of a request   Example usage:   val printer = Printer.fromConfiguration(PrintingConfiguration.PRETTY)\n      .toBuilder()\n      .metaStrategy(MetaStrategy.builder()\n          .includeId()\n          .includeTypename()\n          .include(\"TODO\") { fragment ->\n             fragment.typeName == \"User\"\n          }\n          .build())\n      .indent(\"\\t\")\n      .build()  The above  printer  shows how to format your requests as pretty-printed with tab indents, and also adds a property called \"TODO\" to a fragment selection set when the fragment is of type  User .  Note that fragments themselves can be easily formatted for standard day-to-day usage:    val fragment = ...\n  val stringQuery = fragment.toGraphQl(\n      pretty = true,\n      idAndTypeName = true)",
            "title": "Printer"
        },
        {
            "location": "/core/#graph-visitor",
            "text": "This is an interface for analyzing fragment structure. Internally, the Printer and many other features use this interface under the hood. For example, here is the implementation of the Fragment's overload of the  in  operator (for checking if a fragment is defined within another one, e.g.  if (fragment in otherFragment) doSmth(); ):    operator fun Fragment.contains(other: Fragment): Boolean {\n    var result = false\n\n    GraphVisitor.builder()\n        .onNotifyEnter {\n          other != it || let {\n            result = true\n            false // stop traversing, found match\n          }\n        }\n        .build()\n        .let(::traverse)\n\n    return result\n  }",
            "title": "Graph Visitor"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\u00b6\n\n\nInterested in contributing to the Material theme? Want to report a bug? Before\nyou do, please read the following guidelines.\n\n\nSubmission context\n\u00b6\n\n\nGot a question or problem?\n\u00b6\n\n\nFor quick questions there's no need to open an issue as you can reach us on\n\ngitter.im\n.\n\n\nFound a bug?\n\u00b6\n\n\nIf you found a bug in the source code, you can help us by submitting an issue\nto the \nissue tracker\n in our GitHub repository. Even better, you can submit\na Pull Request with a fix. However, before doing so, please read the\n\nsubmission guidelines\n.\n\n\nMissing a feature?\n\u00b6\n\n\nYou can request a new feature by submitting an issue to our GitHub Repository.\nIf you would like to implement a new feature, please submit an issue with a\nproposal for your work first, to be sure that it is of use for everyone, as\nthe Material theme is highly opinionated. Please consider what kind of change\nit is:\n\n\n\n\n\n\nFor a \nmajor feature\n, first open an issue and outline your proposal so\n  that it can be discussed. This will also allow us to better coordinate our\n  efforts, prevent duplication of work, and help you to craft the change so\n  that it is successfully accepted into the project.\n\n\n\n\n\n\nSmall features and bugs\n can be crafted and directly submitted as a Pull\n  Request. However, there is no guarantee that your feature will make it into\n  the master, as it's always a matter of opinion whether if benefits the\n  overall functionality of the theme.\n\n\n\n\n\n\nSubmission guidelines\n\u00b6\n\n\nSubmitting an issue\n\u00b6\n\n\nBefore you submit an issue, please search the issue tracker, maybe an issue for\nyour problem already exists and the discussion might inform you of workarounds\nreadily available.\n\n\nWe want to fix all the issues as soon as possible, but before fixing a bug we\nneed to reproduce and confirm it. In order to reproduce bugs we will\nsystematically ask you to provide a minimal reproduction scenario using the\ncustom issue template. Please stick to the issue template.\n\n\nUnfortunately we are not able to investigate / fix bugs without a minimal\nreproduction scenario, so if we don't hear back from you we may close the issue.\n\n\nSubmitting a Pull Request (PR)\n\u00b6\n\n\nSearch GitHub for an open or closed PR that relates to your submission. You\ndon't want to duplicate effort. If you do not find a related issue or PR,\ngo ahead.\n\n\n\n\n\n\nDevelopment\n: Fork the project, set up the development environment,\n  make your changes in a separate git branch and add descriptive messages to\n  your commits.\n\n\n\n\n\n\nBuild\n: Before submitting a pull requests, build the theme. This is a\n  mandatory requirement for your PR to objectValue accepted, as the theme should at\n  all times be installable through GitHub.\n\n\n\n\n\n\nPull Request\n: After building the theme, commit the compiled output, push\n  your branch to GitHub and send a PR to \nmkdocs-material:master\n. If we\n  suggest changes, make the required updates, rebase your branch and push the\n  changes to your GitHub repository, which will automatically update your PR.\n\n\n\n\n\n\nAfter your PR is merged, you can safely delete your branch and pull the changes\nfrom the main (upstream) repository.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#contributing",
            "text": "Interested in contributing to the Material theme? Want to report a bug? Before\nyou do, please read the following guidelines.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#submission-context",
            "text": "",
            "title": "Submission context"
        },
        {
            "location": "/contributing/#got-a-question-or-problem",
            "text": "For quick questions there's no need to open an issue as you can reach us on gitter.im .",
            "title": "Got a question or problem?"
        },
        {
            "location": "/contributing/#found-a-bug",
            "text": "If you found a bug in the source code, you can help us by submitting an issue\nto the  issue tracker  in our GitHub repository. Even better, you can submit\na Pull Request with a fix. However, before doing so, please read the submission guidelines .",
            "title": "Found a bug?"
        },
        {
            "location": "/contributing/#missing-a-feature",
            "text": "You can request a new feature by submitting an issue to our GitHub Repository.\nIf you would like to implement a new feature, please submit an issue with a\nproposal for your work first, to be sure that it is of use for everyone, as\nthe Material theme is highly opinionated. Please consider what kind of change\nit is:    For a  major feature , first open an issue and outline your proposal so\n  that it can be discussed. This will also allow us to better coordinate our\n  efforts, prevent duplication of work, and help you to craft the change so\n  that it is successfully accepted into the project.    Small features and bugs  can be crafted and directly submitted as a Pull\n  Request. However, there is no guarantee that your feature will make it into\n  the master, as it's always a matter of opinion whether if benefits the\n  overall functionality of the theme.",
            "title": "Missing a feature?"
        },
        {
            "location": "/contributing/#submission-guidelines",
            "text": "",
            "title": "Submission guidelines"
        },
        {
            "location": "/contributing/#submitting-an-issue",
            "text": "Before you submit an issue, please search the issue tracker, maybe an issue for\nyour problem already exists and the discussion might inform you of workarounds\nreadily available.  We want to fix all the issues as soon as possible, but before fixing a bug we\nneed to reproduce and confirm it. In order to reproduce bugs we will\nsystematically ask you to provide a minimal reproduction scenario using the\ncustom issue template. Please stick to the issue template.  Unfortunately we are not able to investigate / fix bugs without a minimal\nreproduction scenario, so if we don't hear back from you we may close the issue.",
            "title": "Submitting an issue"
        },
        {
            "location": "/contributing/#submitting-a-pull-request-pr",
            "text": "Search GitHub for an open or closed PR that relates to your submission. You\ndon't want to duplicate effort. If you do not find a related issue or PR,\ngo ahead.    Development : Fork the project, set up the development environment,\n  make your changes in a separate git branch and add descriptive messages to\n  your commits.    Build : Before submitting a pull requests, build the theme. This is a\n  mandatory requirement for your PR to objectValue accepted, as the theme should at\n  all times be installable through GitHub.    Pull Request : After building the theme, commit the compiled output, push\n  your branch to GitHub and send a PR to  mkdocs-material:master . If we\n  suggest changes, make the required updates, rebase your branch and push the\n  changes to your GitHub repository, which will automatically update your PR.    After your PR is merged, you can safely delete your branch and pull the changes\nfrom the main (upstream) repository.",
            "title": "Submitting a Pull Request (PR)"
        },
        {
            "location": "/license/",
            "text": "License\n\u00b6\n\n\nMIT License\n\n\nCopyright \u00a9 2016 - 2017 Preston Garno\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.",
            "title": "License"
        },
        {
            "location": "/license/#license",
            "text": "MIT License  Copyright \u00a9 2016 - 2017 Preston Garno  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.",
            "title": "License"
        }
    ]
}